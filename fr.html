<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js - Cubo Rojo</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/examples/js/controls/OrbitControls.js"></script>\
conts 
  <script>
    // Configuración de la escena
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Crear cubo rojo
    const geometry = new THREE.BoxGeometry(2, 2, 2);
    const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const cube = new THREE.Mesh(geometry, material);
    scene.add(cube);

    // Plano cartesiano transparente
    const gridHelper = new THREE.GridHelper(20, 20, 0x888888, 0x444444);
    gridHelper.material.transparent = true;
    gridHelper.material.opacity = 0.3;
    scene.add(gridHelper);

    // Ejes de coordenadas (X=rojo, Y=verde, Z=azul)
    const axesHelper = new THREE.AxesHelper(10);
    scene.add(axesHelper);

    // Posición de la cámara
    camera.position.z = 5;

    // Variables para controles del ratón
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let cameraRotation = { x: 0, y: 0 };
    const cameraDistance = 8;

    // Eventos del ratón para mover la cámara
    renderer.domElement.addEventListener('mousedown', (e) => {
      isDragging = true;
      previousMousePosition = { x: e.clientX, y: e.clientY };
    });

    renderer.domElement.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const deltaX = e.clientX - previousMousePosition.x;
        const deltaY = e.clientY - previousMousePosition.y;
        
        cameraRotation.y += deltaX * 0.005;
        cameraRotation.x += deltaY * 0.005;
        
        // Limitar rotación vertical
        cameraRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotation.x));
        
        previousMousePosition = { x: e.clientX, y: e.clientY };
      }
    });

    renderer.domElement.addEventListener('mouseup', () => {
      isDragging = false;
    });

    renderer.domElement.addEventListener('mouseleave', () => {
      isDragging = false;
    });

    // Ajustar al redimensionar ventana
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Bucle de animación
    function animate() {
      requestAnimationFrame(animate);

      // Rotar el cubo
      cube.rotation.x += 0.01;
      cube.rotation.y += 0.01;

      // Actualizar posición de la cámara basada en rotación
      camera.position.x = Math.sin(cameraRotation.y) * Math.cos(cameraRotation.x) * cameraDistance;
      camera.position.y = Math.sin(cameraRotation.x) * cameraDistance;
      camera.position.z = Math.cos(cameraRotation.y) * Math.cos(cameraRotation.x) * cameraDistance;
      camera.lookAt(0, 0, 0);

      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
      const farola = new THREE.Group();
      
      // Poste
      const posteGeo = new THREE.CylinderGeometry(0.25, 0.25, 10, 6);
      const posteMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
      const poste = new THREE.Mesh(posteGeo, posteMat);
      poste.position.y = 5;
      farola.add(poste);
      
      // Lámpara
      const lamparaGeo = new THREE.SphereGeometry(0.7, 8, 8);
      const lamparaMat = new THREE.MeshStandardMaterial({ 
        color: 0xffffcc, 
        emissive: 0xffffcc, 
        emissiveIntensity: 2 
      });
      const lampara = new THREE.Mesh(lamparaGeo, lamparaMat);
      lampara.position.y = 10;
      farola.add(lampara);
      
      // Solo una luz por farola
      const luzFarola = new THREE.PointLight(0xffffcc, 2, 40);
      luzFarola.position.y = 10;
      farola.add(luzFarola);
      
      farola.position.set(x, 0, z);
      scene.add(farola);
      edificios.push(farola);
      return farola;
    }

    // Carretera infinita
    const carreteras = [];
    const callesLaterales = [];
    const edificios = [];
    let velocidadCarro = 0.5;

    // Función para crear segmento de carretera
    function crearCarretera(z) {
      const carreteraGeo = new THREE.BoxGeometry(20, 0.1, 50);
      const carreteraMat = new THREE.MeshStandardMaterial({ color: 0x505050 });
      const carretera = new THREE.Mesh(carreteraGeo, carreteraMat);
      carretera.position.set(0, 0, z);
      scene.add(carretera);
      
      // Líneas amarillas centrales
      for (let i = 0; i < 5; i++) {
        const lineaGeo = new THREE.BoxGeometry(0.3, 0.11, 8);
        const lineaMat = new THREE.MeshStandardMaterial({ color: 0xffff00 });
        const linea = new THREE.Mesh(lineaGeo, lineaMat);
        linea.position.set(0, 0.06, z - 20 + i * 10);
        scene.add(linea);
        carreteras.push(linea);
      }
      
      carreteras.push(carretera);
      return carretera;
    }

    // Función para crear calle cruzada
    function crearCalleCruzada(z) {
      const calleGeo = new THREE.BoxGeometry(80, 0.11, 15);
      const calleMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a });
      const calle = new THREE.Mesh(calleGeo, calleMat);
      calle.position.set(0, 0.06, z);
      scene.add(calle);
      callesLaterales.push(calle);
      return calle;
    }

    // Función para crear edificio (optimizado)
    function crearEdificio(x, z, altura) {
      const edificio = new THREE.Group();
      
      const baseGeo = new THREE.BoxGeometry(15, altura, 15);
      const baseMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.y = altura / 2;
      edificio.add(base);
      
      // Solo algunas ventanas (reducido)
      const ventanasFilas = Math.floor(altura / 6);
      for (let i = 0; i < ventanasFilas; i++) {
        for (let j = 0; j < 2; j++) {
          if (Math.random() > 0.4) {
            const ventanaGeo = new THREE.BoxGeometry(2, 2, 0.2);
            const ventanaMat = new THREE.MeshStandardMaterial({ 
              color: 0xffdd44, 
              emissive: 0xffdd44,
              emissiveIntensity: 0.6
            });
            const ventana = new THREE.Mesh(ventanaGeo, ventanaMat);
            ventana.position.set(-4 + j * 8, 5 + i * 6, 7.6);
            edificio.add(ventana);
          }
        }
      }
      
      edificio.position.set(x, 0, z);
      scene.add(edificio);
      edificios.push(edificio);
      return edificio;
    }

    // Función para crear casa (simplificada)
    function crearCasa(x, z) {
      const casa = new THREE.Group();
      
      const baseGeo = new THREE.BoxGeometry(10, 8, 10);
      const baseMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.y = 4;
      casa.add(base);
      
      // Techo
      const techoGeo = new THREE.ConeGeometry(7, 4, 4);
      const techoMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
      const techo = new THREE.Mesh(techoGeo, techoMat);
      techo.position.y = 10;
      techo.rotation.y = Math.PI / 4;
      casa.add(techo);
      
      // Solo una ventana
      const ventanaGeo = new THREE.BoxGeometry(2, 2, 0.2);
      const ventanaMat = new THREE.MeshStandardMaterial({ 
        color: 0xffaa00, 
        emissive: 0xffaa00,
        emissiveIntensity: 0.8
      });
      const ventana = new THREE.Mesh(ventanaGeo, ventanaMat);
      ventana.position.set(0, 5, 5.1);
      casa.add(ventana);
      
      casa.position.set(x, 0, z);
      scene.add(casa);
      edificios.push(casa);
      return casa;
    }

    // Generar carreteras iniciales (reducido)
    for (let i = 0; i < 8; i++) {
      crearCarretera(-i * 50);
    }

    // Generar ciudad inicial (optimizado)
    for (let i = 0; i < 15; i++) {
      const z = -i * 35;
      
      // Calles cruzadas cada cierta distancia
      if (i % 5 === 0) {
        crearCalleCruzada(z);
      }
      
      // Farolas solo cada 35 unidades
      crearFarola(-12, z);
      crearFarola(12, z);
      
      // Edificios solo en algunos lugares
      if (i % 2 === 0) {
        const altura = 20 + Math.random() * 30;
        crearEdificio(-35, z, altura);
        crearEdificio(35, z, 20 + Math.random() * 30);
      }
      
      // Menos casas
      if (i % 3 === 0) {
        crearCasa(-55, z - 10);
        crearCasa(55, z - 10);
      }
    }

    // Faros delanteros del carro (más intensos y visibles)
    const faroIzq = new THREE.SpotLight(0xffffee, 4, 180, Math.PI / 4.5, 0.7);
    faroIzq.position.set(-1.5, 1.5, 2.5);
    faroIzq.target.position.set(-3, 0, -80);
    faroIzq.castShadow = true;
    scene.add(faroIzq);
    scene.add(faroIzq.target);

    const faroDer = new THREE.SpotLight(0xffffee, 4, 180, Math.PI / 4.5, 0.7);
    faroDer.position.set(1.5, 1.5, 2.5);
    faroDer.target.position.set(3, 0, -80);
    faroDer.castShadow = true;
    scene.add(faroDer);
    scene.add(faroDer.target);

    // Luces de los faros visibles (geometría) - más grandes
    const luzFaroGeo = new THREE.CylinderGeometry(0.2, 0.25, 0.4, 16);
    const luzFaroMat = new THREE.MeshStandardMaterial({ 
      color: 0xffffee, 
      emissive: 0xffffee, 
      emissiveIntensity: 1.5 
    });
    const luzFaroIzq = new THREE.Mesh(luzFaroGeo, luzFaroMat);
    luzFaroIzq.rotation.x = Math.PI / 2;
    luzFaroIzq.position.set(-1.5, 1.5, 2.2);
    scene.add(luzFaroIzq);

    const luzFaroDer = new THREE.Mesh(luzFaroGeo, luzFaroMat);
    luzFaroDer.rotation.x = Math.PI / 2;
    luzFaroDer.position.set(1.5, 1.5, 2.2);
    scene.add(luzFaroDer);

    // Luces traseras rojas
    const luzTraseraGeo = new THREE.BoxGeometry(0.6, 0.3, 0.15);
    const luzTraseraMat = new THREE.MeshStandardMaterial({ 
      color: 0xff0000, 
      emissive: 0xff0000, 
      emissiveIntensity: 1.2 
    });
    const luzTraseraIzq = new THREE.Mesh(luzTraseraGeo, luzTraseraMat);
    luzTraseraIzq.position.set(-1.5, 1.8, 6);
    scene.add(luzTraseraIzq);

    const luzTraseraDer = new THREE.Mesh(luzTraseraGeo, luzTraseraMat);
    luzTraseraDer.position.set(1.5, 1.8, 6);
    scene.add(luzTraseraDer);

    // Luz roja ambiental de las luces traseras
    const luzRojaIzq = new THREE.PointLight(0xff0000, 0.8, 15);
    luzRojaIzq.position.set(-1.5, 1.8, 6.5);
    scene.add(luzRojaIzq);

    const luzRojaDer = new THREE.PointLight(0xff0000, 0.8, 15);
    luzRojaDer.position.set(1.5, 1.8, 6.5);
    scene.add(luzRojaDer);

    // Interior del carro
    const interiorCarro = new THREE.Group();

    // Volante del carro (más grande y visible)
    const volanteGeo = new THREE.TorusGeometry(1, 0.12, 20, 40);
    const volanteMat = new THREE.MeshStandardMaterial({ 
      color: 0x0a0a0a,
      roughness: 0.3,
      metalness: 0.5
    });
    const volante = new THREE.Mesh(volanteGeo, volanteMat);
    volante.position.set(0, 2.4, 3.5);
    volante.rotation.x = Math.PI / 3;
    interiorCarro.add(volante);

    // Centro del volante con logo (más grande)
    const centroVolanteGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.12, 20);
    const centroVolanteMat = new THREE.MeshStandardMaterial({ 
      color: 0x1a1a1a,
      emissive: 0x333333,
      emissiveIntensity: 0.3
    });
    const centroVolante = new THREE.Mesh(centroVolanteGeo, centroVolanteMat);
    centroVolante.position.copy(volante.position);
    centroVolante.rotation.copy(volante.rotation);
    interiorCarro.add(centroVolante);

    // Columna del volante
    const columnaGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.8, 16);
    const columnaMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a });
    const columna = new THREE.Mesh(columnaGeo, columnaMat);
    columna.position.set(0, 2.1, 3.7);
    columna.rotation.x = Math.PI / 6;
    interiorCarro.add(columna);

    // Dashboard principal
    const dashGeo = new THREE.BoxGeometry(4, 0.4, 1.2);
    const dashMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
    const dashboard = new THREE.Mesh(dashGeo, dashMat);
    dashboard.position.set(0, 1.9, 4.2);
    dashboard.rotation.x = -Math.PI / 6;
    interiorCarro.add(dashboard);

    // Consola central
    const consolaGeo = new THREE.BoxGeometry(0.8, 0.6, 1.5);
    const consolaMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a });
    const consola = new THREE.Mesh(consolaGeo, consolaMat);
    consola.position.set(0, 1.6, 4.5);
    interiorCarro.add(consola);

    // Palanca de cambios
    const palancaBaseGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.4, 16);
    const palancaMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
    const palancaBase = new THREE.Mesh(palancaBaseGeo, palancaMat);
    palancaBase.position.set(0.2, 1.9, 4.3);
    interiorCarro.add(palancaBase);

    const palancaPomoGeo = new THREE.SphereGeometry(0.12, 16, 16);
    const palancaPomo = new THREE.Mesh(palancaPomoGeo, volanteMat);
    palancaPomo.position.set(0.2, 2.1, 4.3);
    interiorCarro.add(palancaPomo);

    // Asiento del conductor
    const asientoBaseGeo = new THREE.BoxGeometry(1.2, 0.3, 1.2);
    const asientoMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
    const asientoBase = new THREE.Mesh(asientoBaseGeo, asientoMat);
    asientoBase.position.set(0, 1.2, 5);
    interiorCarro.add(asientoBase);

    const respaldoGeo = new THREE.BoxGeometry(1.2, 1.5, 0.3);
    const respaldo = new THREE.Mesh(respaldoGeo, asientoMat);
    respaldo.position.set(0, 2.2, 5.5);
    respaldo.rotation.x = -0.2;
    interiorCarro.add(respaldo);

    // Reposabrazos
    const reposabrazosGeo = new THREE.BoxGeometry(0.2, 0.15, 0.8);
    const reposabrazosIzq = new THREE.Mesh(reposabrazosGeo, consolaMat);
    reposabrazosIzq.position.set(-0.7, 1.5, 4.8);
    interiorCarro.add(reposabrazosIzq);

    const reposabrazosDer = new THREE.Mesh(reposabrazosGeo, consolaMat);
    reposabrazosDer.position.set(0.7, 1.5, 4.8);
    interiorCarro.add(reposabrazosDer);

    // Marco del parabrisas (borde superior)
    const marcoSuperiorGeo = new THREE.BoxGeometry(4, 0.1, 0.1);
    const marcoMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a });
    const marcoSuperior = new THREE.Mesh(marcoSuperiorGeo, marcoMat);
    marcoSuperior.position.set(0, 3.8, 3);
    interiorCarro.add(marcoSuperior);

    // Pilares del parabrisas (A-pillars)
    const pilarGeo = new THREE.BoxGeometry(0.15, 2, 0.15);
    const pilarIzq = new THREE.Mesh(pilarGeo, marcoMat);
    pilarIzq.position.set(-2, 2.8, 3);
    pilarIzq.rotation.z = -0.3;
    interiorCarro.add(pilarIzq);

    const pilarDer = new THREE.Mesh(pilarGeo, marcoMat);
    pilarDer.position.set(2, 2.8, 3);
    pilarDer.rotation.z = 0.3;
    interiorCarro.add(pilarDer);

    // Espejo retrovisor
    const retroBaseGeo = new THREE.BoxGeometry(0.3, 0.05, 0.1);
    const retroBase = new THREE.Mesh(retroBaseGeo, marcoMat);
    retroBase.position.set(0, 3.5, 2.5);
    interiorCarro.add(retroBase);

    const retroEspejoGeo = new THREE.BoxGeometry(0.8, 0.3, 0.05);
    const retroEspejoMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.9, roughness: 0.1 });
    const retroEspejo = new THREE.Mesh(retroEspejoGeo, retroEspejoMat);
    retroEspejo.position.set(0, 3.4, 2.4);
    interiorCarro.add(retroEspejo);

    // Techo interior
    const techoGeo = new THREE.BoxGeometry(3.5, 0.05, 3);
    const techoMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a });
    const techo = new THREE.Mesh(techoGeo, techoMat);
    techo.position.set(0, 3.9, 4);
    interiorCarro.add(techo);

    // Luz interior del techo
    const luzInteriorGeo = new THREE.BoxGeometry(0.3, 0.06, 0.2);
    const luzInteriorMat = new THREE.MeshStandardMaterial({ color: 0xffffaa, emissive: 0xffffaa, emissiveIntensity: 0.5 });
    const luzInterior = new THREE.Mesh(luzInteriorGeo, luzInteriorMat);
    luzInterior.position.set(0, 3.85, 3.5);
    interiorCarro.add(luzInterior);

    // Puerta lateral izquierda (solo el marco visible)
    const puertaMarcoGeo = new THREE.BoxGeometry(0.1, 1.5, 1.5);
    const puertaIzq = new THREE.Mesh(puertaMarcoGeo, marcoMat);
    puertaIzq.position.set(-2.2, 2.5, 4.5);
    interiorCarro.add(puertaIzq);

    // Puerta lateral derecha
    const puertaDer = new THREE.Mesh(puertaMarcoGeo, marcoMat);
    puertaDer.position.set(2.2, 2.5, 4.5);
    interiorCarro.add(puertaDer);

    // Manijas de puertas
    const manijaGeo = new THREE.BoxGeometry(0.4, 0.1, 0.15);
    const manijaMat = new THREE.MeshStandardMaterial({ color: 0x666666 });
    const manijaIzq = new THREE.Mesh(manijaGeo, manijaMat);
    manijaIzq.position.set(-2.1, 2, 4.5);
    interiorCarro.add(manijaIzq);

    const manijaDer = new THREE.Mesh(manijaGeo, manijaMat);
    manijaDer.position.set(2.1, 2, 4.5);
    interiorCarro.add(manijaDer);

    scene.add(interiorCarro);

    // Cubos que aparecen cada 5 segundos (limitado a 3)
    let ultimoCuboTiempo = Date.now();
    const cubos = [];
    const MAX_CUBOS = 3;

    function crearCuboSorpresa() {
      if (cubos.length >= MAX_CUBOS) return; // No crear más si ya hay 3
      
      const cuboGeo = new THREE.BoxGeometry(3, 3, 3);
      const cuboMat = new THREE.MeshStandardMaterial({ 
        color: 0xff0000, 
        emissive: 0xff0000, 
        emissiveIntensity: 0.8 
      });
      const cubo = new THREE.Mesh(cuboGeo, cuboMat);
      const lado = Math.random() > 0.5 ? 25 : -25;
      cubo.position.set(lado, 3, -30);
      
      // Luz roja alrededor del cubo
      const luzCubo = new THREE.PointLight(0xff0000, 1.5, 15);
      luzCubo.position.copy(cubo.position);
      scene.add(luzCubo);
      cubo.userData.luz = luzCubo;
      
      scene.add(cubo);
      cubos.push(cubo);
    }

    // Controles de dirección
    const keys = { w: false, s: false, a: false, d: false };
    window.addEventListener('keydown', (e) => {
      if (e.key === 'w' || e.key === 'W') keys.w = true;
      if (e.key === 's' || e.key === 'S') keys.s = true;
      if (e.key === 'a' || e.key === 'A') keys.a = true;
      if (e.key === 'd' || e.key === 'D') keys.d = true;
    });
    window.addEventListener('keyup', (e) => {
      if (e.key === 'w' || e.key === 'W') keys.w = false;
      if (e.key === 's' || e.key === 'S') keys.s = false;
      if (e.key === 'a' || e.key === 'A') keys.a = false;
      if (e.key === 'd' || e.key === 'D') keys.d = false;
    });

    // Ajustar al redimensionar ventana
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Bucle de animación
    function animate() {
      requestAnimationFrame(animate);

      // Crear un nuevo cubo cada 5 segundos
      const tiempoActual = Date.now();
      if (tiempoActual - ultimoCuboTiempo >= 5000) {
        crearCuboSorpresa();
        ultimoCuboTiempo = tiempoActual;
      }

      // Animar cubos
      for (let i = cubos.length - 1; i >= 0; i--) {
        const cubo = cubos[i];
        cubo.rotation.x += 0.02;
        cubo.rotation.y += 0.02;
        cubo.position.z += velocidadCarro;
        
        // Actualizar posición de la luz
        if (cubo.userData.luz) {
          cubo.userData.luz.position.copy(cubo.position);
        }
        
        // Eliminar si pasa de largo
        if (cubo.position.z > 50) {
          scene.remove(cubo);
          if (cubo.userData.luz) {
            scene.remove(cubo.userData.luz);
          }
          cubos.splice(i, 1);
        }
      }

      // Controles de velocidad
      if (keys.w && velocidadCarro < 2) velocidadCarro += 0.02;
      if (keys.s && velocidadCarro > 0) velocidadCarro -= 0.02;

      // Movimiento infinito de carretera y edificios
      carreteras.forEach((obj, index) => {
        obj.position.z += velocidadCarro;
        if (obj.position.z > 50) {
          obj.position.z = -500;
        }
      });

      callesLaterales.forEach((obj) => {
        obj.position.z += velocidadCarro;
        if (obj.position.z > 50) {
          obj.position.z = -600;
        }
      });

      edificios.forEach((obj) => {
        obj.position.z += velocidadCarro;
        if (obj.position.z > 50) {
          obj.position.z = -600;
          // Randomizar altura de edificios al reciclar
          if (obj.children[0].geometry.parameters.height > 15) {
            const nuevaAltura = 20 + Math.random() * 40;
            obj.children[0].scale.y = nuevaAltura / obj.children[0].geometry.parameters.height;
          }
        }
      });

      // Giro suave del volante
      if (keys.a) {
        volante.rotation.z = Math.min(volante.rotation.z + 0.01, Math.PI / 6);
      } else if (keys.d) {
        volante.rotation.z = Math.max(volante.rotation.z - 0.01, -Math.PI / 6);
      } else {
        volante.rotation.z *= 0.95; // Volver al centro
      }

      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>